将子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

---

Facade:知道哪些子系统类负责处理请求，并且将客户的请求代理给适当的子系统对象；

SubSystem:实现子系统具体的功能；处理由Facade对象指派的任务；但是，SubSystem没有Facade的任何相关信息，也就是说，没有指向Facade的指针。

Client通过发送请求给Facade的方式与子系统进行通信，而不直接与子系统打交道，Facade将这些消息转发给适当的子系统对象。尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。


优点
+ 它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目，并使得子系统使用起来更加方便；
+ 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的；松耦合系统使得子系统的组件变化不会影响到它的客户。外观模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。外观模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。

使用场合
+ 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变的越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具有可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。外观模式可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层；
+ 当客户程序与抽象类的实现部分之间存在很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性；
+ 当需要构建一个层次结构的子系统时，使用外观模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，我们就可以让它们仅通过Facade进行通讯，从而简化了它们之间的依赖关系。


Reference:
+ https://www.cnblogs.com/ring1992/p/9593112.html