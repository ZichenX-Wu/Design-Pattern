装饰器模式: 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。

装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象添加功能。通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，而我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。总之，装饰模式是通过把复杂的功能简单化，分散化，然后再运行期间，根据需要来动态组合的这样一个模式。它使得我们可以给某个对象而不是整个类添加一些功能。



装饰器模式在代码层面上的核心是: 双重多态
第一次多态: Decorator 与 ConcreteDecorator 之间的多态
第二次多态: Component 与 ConcreteComponent 之间的多态

原因在于 Decorator 的 Operation 中会去使用 m_pComponent来调用它所指向的对象的 Operation() 方法.
这个过程是必要的! 因为前面所有的过程都是在 "装饰" 的过程, 此处才是真正的去调用 原始的 Operation() 方法.
在Decorator的构造函数中对 m_pComponent 赋值时, 赋予的值是 ConcreteComponent 对象, 因此在 m_pComponent 调用Operation()时才会形成第二次的多态.






装饰器模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。

(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图 4 所示。


(2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图 5 所示。


References:
1. https://www.cnblogs.com/ring1992/p/9593074.html
2. https://zhuanlan.zhihu.com/p/444298983